## 109. Convert Sorted List to Binary Search Tree 
## 108. Convert Sorted Array to Binary Search Tree  
## 107. Binary Tree Level Order Traversal II  
## 106. Construct Binary Tree from Inorder and Postorder Traversal  
## 105. Construct Binary Tree from Preorder and Inorder Traversal 
## 104. Maximum Depth of Binary Tree  
## 103. Binary Tree Zigzag Level Order Traversal 

Same as the previous one. Just reverse the nodes depending on what level they are at.

```cpp
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> results;
        TraverseTreeLevelByLevel(
            root,
            [&results](Nodes& nodes, int level) {
                if (level % 2) {
                    std::reverse(nodes.begin(), nodes.end());
                }
                results.emplace_back(nodes);
            });
        return results;
    }
```
    
## 102. Binary Tree Level Order Traversal 

Key points: remember #of nodes on current level and next level two. See
`remaining_at_current_level` and `remaining_at_next_level`.

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> results;
        TraverseTreeLevelByLevel(
            root,
            [&results](const Nodes& nodes, int level) {
                results.emplace_back(nodes);
            });
        return results;
    }

    ////////////////////////////////////////////////////
    using Nodes = vector<int>;
    
    // For each level call the provided function.
    void TraverseTreeLevelByLevel(
        TreeNode* root,
        std::function<void(const Nodes&, int)> func) {
        if (root == nullptr) return;
        
        std::queue<TreeNode*> q;
        q.push(root);
        Nodes current;
        int cur_level = 0;  // Current level (starting from 0).
        int remaining_at_current_level = 1;  // #of nodes on the current level in the stack.
        int remaining_at_next_level = 0;  // #of nodes on the next level in the stack.
        while (!q.empty()) {
            TreeNode* front = q.front();
            q.pop();
            --remaining_at_current_level;
            current.emplace_back(front->val);
            if (front->left) {
                q.push(front->left);
                ++remaining_at_next_level;
            }
            if (front->right) {
                q.push(front->right);
                ++remaining_at_next_level;
            }
            if (remaining_at_current_level == 0) {
                func(current, cur_level);
                remaining_at_current_level = remaining_at_next_level;
                remaining_at_next_level = 0;
                ++cur_level;
                current.clear();
            }
        }
    }
};
```

## 101. Symmetric Tree  

Recursive solution is easy.
```cpp
class Solution {
public:
    // Whether two trees are mirrored.
    bool isMirrored(TreeNode* p, TreeNode* q) {
        if (!p) return !q;
        if (!q) return !p;
        return p->val == q->val  && 
               isMirrored(p->left, q->right) &&
               isMirrored(p->right, q->left);
    }
    
    bool isSymmetric(TreeNode* root) {
        return !root || isMirrored(root->left, root->right);
    }
};
```
The following iterative solution is from internet. It is a neat one. It uses two
stacks to respectively iterate the given two trees in left-root-right and
right-root-left order.

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        std::stack<TreeNode*> stnl;
        std::stack<TreeNode*> stnr;
        stnl.push(root), stnr.push(root);
        TreeNode *p, *q;
        while(!stnl.empty()) {
            p=stnl.top(), q=stnr.top();
            if((!p^!q) || p && q && p->val!=q->val) break;
            stnl.pop(), stnr.pop();
            if(p && q) {
                stnl.push(p->left), stnl.push(p->right);
                stnr.push(q->right), stnr.push(q->left);
            }
        }
        return stnl.empty();
    }
};
```

## 100. Same Tree

A simple tree recursion.

```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (!p) return !q;
        if (!q) return !p;
        return p->val == q->val  && 
               isSameTree(p->left, q->left) &&
               isSameTree(p->right, q->right);
    }
};
```
