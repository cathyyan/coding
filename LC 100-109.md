## 109. Convert Sorted List to Binary Search Tree 
## 108. Convert Sorted Array to Binary Search Tree  
## 107. Binary Tree Level Order Traversal II  
## 106. Construct Binary Tree from Inorder and Postorder Traversal  
## 105. Construct Binary Tree from Preorder and Inorder Traversal 
## 104. Maximum Depth of Binary Tree  
## 103. Binary Tree Zigzag Level Order Traversal  
## 102. Binary Tree Level Order Traversal 
## 101. Symmetric Tree  

Recursive solution is easy.
```cpp
class Solution {
public:
    // Whether two trees are mirrored.
    bool isMirrored(TreeNode* p, TreeNode* q) {
        if (!p) return !q;
        if (!q) return !p;
        return p->val == q->val  && 
               isMirrored(p->left, q->right) &&
               isMirrored(p->right, q->left);
    }
    
    bool isSymmetric(TreeNode* root) {
        return !root || isMirrored(root->left, root->right);
    }
};
```
The following iterative solution is from internet. It is a neat one. It uses two
stacks to respectively iterate the given two trees in left-root-right and
right-root-left order.

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        std::stack<TreeNode*> stnl;
        std::stack<TreeNode*> stnr;
        stnl.push(root), stnr.push(root);
        TreeNode *p, *q;
        while(!stnl.empty()) {
            p=stnl.top(), q=stnr.top();
            if((!p^!q) || p && q && p->val!=q->val) break;
            stnl.pop(), stnr.pop();
            if(p && q) {
                stnl.push(p->left), stnl.push(p->right);
                stnr.push(q->right), stnr.push(q->left);
            }
        }
        return stnl.empty();
    }
};
```

## 100. Same Tree

A simple tree recursion.

```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (!p) return !q;
        if (!q) return !p;
        return p->val == q->val  && 
               isSameTree(p->left, q->left) &&
               isSameTree(p->right, q->right);
    }
};
```
