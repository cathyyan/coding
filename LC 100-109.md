## 109. Convert Sorted List to Binary Search Tree 
## 108. Convert Sorted Array to Binary Search Tree  
## 107. Binary Tree Level Order Traversal II  
## 106. Construct Binary Tree from Inorder and Postorder Traversal  
## 105. Construct Binary Tree from Preorder and Inorder Traversal 
## 104. Maximum Depth of Binary Tree  
## 103. Binary Tree Zigzag Level Order Traversal  
## 102. Binary Tree Level Order Traversal 
## 101. Symmetric Tree  

Recursive solution is easy.
```cpp
class Solution {
public:
    // Whether two trees are mirrored.
    bool isMirrored(TreeNode* p, TreeNode* q) {
        if (!p) return !q;
        if (!q) return !p;
        return p->val == q->val  && 
               isMirrored(p->left, q->right) &&
               isMirrored(p->right, q->left);
    }
    
    bool isSymmetric(TreeNode* root) {
        return !root || isMirrored(root->left, root->right);
    }
};
```

The iterative version is to traverse the tree in level order, and for each
level, check whether elements are mirrored. Note the code below is __incomplete__.

```cpp
lass Solution {
public:
    using Nodes = vector<int>;
    
    // For each level call the provided function.
    void TraverseTreeLevelByLevel(
        TreeNode* root,
        std::function<bool(const Nodes&, int)> func) {
        if (root == nullptr) return;
        
        std::queue<TreeNode*> q;
        q.push(root);
        Nodes current;
        int cur_level = 0;  // Current level (starting from 0).
        int remaining_at_current_level = 1;  // #of nodes on the current level in the stack.
        int remaining_at_next_level = 0;  // #of nodes on the next level in the stack.
        bool callback = true;
        while (!q.empty()) {
            TreeNode* front = q.front();
            q.pop();
            --remaining_at_current_level;
            current.emplace_back(front->val);
            if (front->left) {
                q.push(front->left);
                ++remaining_at_next_level;
            }
            if (front->right) {
                q.push(front->right);
                ++remaining_at_next_level;
            }
            if (remaining_at_current_level == 0) {
                if (callback) {
                    callback = func(current, cur_level);
                }
                remaining_at_current_level = remaining_at_next_level;
                remaining_at_next_level = 0;
                ++cur_level;
                current.clear();
            }
        }
    }
    
    bool isSymmetric(TreeNode* root) {
        bool ret = true;
        TraverseTreeLevelByLevel(root, [&ret](const Nodes& nodes) {
            for (std::size_t i = 0, j = nodes.size() - 1; i < j; ++i, --j) {
                if (nodes[i] != nodes[j]) {
                    ret = false;
                    return false;
                }
            }
            return true;
        });
        return ret;
    }
};
```

## 100. Same Tree

A simple tree recursion.

```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (!p) return !q;
        if (!q) return !p;
        return p->val == q->val  && 
               isSameTree(p->left, q->left) &&
               isSameTree(p->right, q->right);
    }
};
```
