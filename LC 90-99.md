## 99. Recover Binary Search Tree  
## 98. Validate Binary Search Tree 
## 97. Interleaving String 
## 96. Unique Binary Search Trees  
## 95. Unique Binary Search Trees II 
## 94. Binary Tree Inorder Traversal 
## 93. Restore IP Addresses  
## 92. Reverse Linked List II  

'1 ≤ m ≤ n ≤ length of list.' simplifies the problem a LOT.

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverse(ListNode* head) {
        ListNode* done = nullptr;
        while (head) {
            ListNode* tmp = head;
            head = head->next;
            tmp->next = done;
            done = tmp;
        }
        return done;
    }

    ListNode* reverseBetween(ListNode* head, int m, int n) {
        ListNode dummy(0);
        dummy.next = head;
        
        ListNode* prev = &dummy;
        for (int i = 0; i < m - 1; ++i) prev = prev->next;
        
        ListNode* tail = head;
        for (int i = 0; i < n - 1; ++i) tail = tail->next;
        
        ListNode* tmp = tail->next;
        tail->next = nullptr;
        tail = prev->next;
        prev->next = reverse(prev->next);
        tail->next = tmp;
        
        return dummy.next;
    }
};
```

## 91. Decode Ways 

Simple one dimentional DP.

```cpp
// 1-D DP.
class Solution {
public:
  bool Valid(char d) {
    return d >= '1' && d <= '9';
  }
  
  bool Valid(const string& s) {
    assert(s.length() == 2);
    int tmp = (s[0] - '0') * 10 + (s[1] - '0');
    return tmp >= 1 && tmp <= 26;
  }
  
  int numDecodings(string s) {
    if (s.empty()) return 0;
    
    std::vector<int> cnts(s.length() + 1, 0);
    int pos = s.length();
    cnts[pos--] = 1;
    cnts[pos] = Valid(s[pos]);
    pos--;
    while (pos >= 0) {
      if (Valid(s[pos])) {
        cnts[pos] = cnts[pos + 1] + (Valid({s, pos, 2}) ? cnts[pos + 2] : 0);
      } else {
        cnts[pos] = 0;
      }
      
      --pos;
    }
    
    return cnts[0];
  }
};
```

## 90. Subsets II

```cpp
class Solution {
public:
  using Subset = vector<int>;
  using Subsets = vector<Subset>;
  
  void FindAllSubsets(Subsets& found, Subset& current,
                     const vector<int>& nums, int pos) {
    found.emplace_back(current);
    
    // Continue find others without choosing the same element for more than
    // once.
    int p = pos;
    while (p < nums.size()) {
      if (p == pos || nums[p] != nums[p - 1]) {   // <--- DEDUP LOGIC HERE>
        current.emplace_back(nums[p]);
        FindAllSubsets(found, current, nums, p + 1);
        current.pop_back();
      }
      ++p;
    }
  }
  
  Subsets subsetsWithDup(Subset& nums) {
    std::sort(nums.begin(), nums.end());
    Subsets results;
    Subset current;
    FindAllSubsets(results, current, nums, 0);
    return results;
  }
};
```
