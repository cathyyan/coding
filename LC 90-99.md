## 99. Recover Binary Search Tree  
## 98. Validate Binary Search Tree 
## 97. Interleaving String 
## 96. Unique Binary Search Trees  
## 95. Unique Binary Search Trees II 

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    // Generate BST trees formed from the numbers in [start, end].
    vector<TreeNode*> GenerateTrees(int start, int end) {
        if (start > end) return { nullptr };
        if (start == end) { return { new TreeNode(start) }; }
        
        vector<TreeNode*> trees;
        for (int v = start; v <= end; ++v) {
            // Use 'v' as the head.
            for (auto left : GenerateTrees(start, v - 1)) {
                for (auto right : GenerateTrees(v + 1, end)) {
                    auto t = new TreeNode(v);
                    t->left = left;
                    t->right = right;
                    trees.emplace_back(t);
                }
            }
        }
        return trees;
    }

    vector<TreeNode*> generateTrees(int n) {
        return GenerateTrees(1, n);
    }
};
```

## 94. Binary Tree Inorder Traversal

The invariance is that every element in stack has to be in-order traversed. To
distinguish elements whose left child has been traversed from those whose both
children remain untraversed, we unset left child pointer after pushing it into
the stack.

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if (root == nullptr) return {};
        
        vector<int> results;
        
        stack<TreeNode*> s;
        s.push(root);
        while (!s.empty()) {
            TreeNode* top = s.top();
            if (top->left != nullptr) {
                s.push(top->left);
                top->left = nullptr;   // <-- This line is required.
            } else {
                s.pop();
                results.emplace_back(top->val);
                if (top->right != nullptr) {
                    s.push(top->right);
                    // top->right = nullptr;  // <- this is optional or unnecessary.
                }
            }
        }
        
        return results;
    }
};
```
## 93. Restore IP Addresses  

Backtrace.

The check before whether we can consume `next` is not clean, which is likely a side-effect of using integers
to represent IP segments. Perhaps a better way is to save them as strings.

```cpp
// Restore IP Addresses
//
// Given a string containing only digits, restore it by returning
// all possible valid IP address combinations.
//
// Backtrace
class Solution {
public:
  using Result = std::vector<int>;
  using Results = std::vector<Result>;
  
  std::string ToString(const Result& result) {
    if (result.empty()) return "";
    
    std::string ret(std::to_string(result.front()));
    for (std::size_t i = 1; i < result.size(); ++i) {
      ret.append(1, '.');
      ret.append(std::to_string(result[i]));
    }
    return ret;
  }
  
  // 'found': results we have found.
  // 'current': IP segments we've identified.
  // 'next': next number to push as the next IP segment.
  void FindAll(Results& found, Result& current, int next, int digits,
               const std::string& s, std::size_t pos) {
    if (pos == s.length() && digits == 0 && current.size() == 4) {
      found.emplace_back(current);
      return;
    }
    
    // Option 1: consume 'next' if any.
    if ((digits > 1 && next >= std::pow(10, digits - 1) || digits == 1) &&
        next <= 255 &&
        current.size() < 4) {
      current.emplace_back(next);
      FindAll(found, current, 0, 0, s, pos);
      current.pop_back();
    }
    
    // Option 2: continue to build 'next' if possible.
    if (pos < s.length()) {
      int tmp = next * 10 + s[pos] - '0';
      if (tmp <= 255) {
        FindAll(found, current, tmp, digits + 1, s, pos + 1);
      }
    }
  }
  
  std::vector<std::string> restoreIpAddresses(std::string s) {
    Results found;
    Result result;
    FindAll(found, result, 0, 0, s, 0);
    
    std::vector<std::string> ret(found.size());
    std::transform(found.begin(), found.end(), ret.begin(),
                   std::bind(&Solution::ToString, this, std::placeholders::_1));
    return ret;
  }
};
```
## 92. Reverse Linked List II  

'1 ≤ m ≤ n ≤ length of list.' simplifies the problem a LOT.

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverse(ListNode* head) {
        ListNode* done = nullptr;
        while (head) {
            ListNode* tmp = head;
            head = head->next;
            tmp->next = done;
            done = tmp;
        }
        return done;
    }

    ListNode* reverseBetween(ListNode* head, int m, int n) {
        ListNode dummy(0);
        dummy.next = head;
        
        ListNode* prev = &dummy;
        for (int i = 0; i < m - 1; ++i) prev = prev->next;
        
        ListNode* tail = head;
        for (int i = 0; i < n - 1; ++i) tail = tail->next;
        
        ListNode* tmp = tail->next;
        tail->next = nullptr;
        tail = prev->next;
        prev->next = reverse(prev->next);
        tail->next = tmp;
        
        return dummy.next;
    }
};
```

## 91. Decode Ways 

Simple one dimentional DP.

```cpp
// 1-D DP.
class Solution {
public:
  bool Valid(char d) {
    return d >= '1' && d <= '9';
  }
  
  bool Valid(const string& s) {
    assert(s.length() == 2);
    int tmp = (s[0] - '0') * 10 + (s[1] - '0');
    return tmp >= 1 && tmp <= 26;
  }
  
  int numDecodings(string s) {
    if (s.empty()) return 0;
    
    std::vector<int> cnts(s.length() + 1, 0);
    int pos = s.length();
    cnts[pos--] = 1;
    cnts[pos] = Valid(s[pos]);
    pos--;
    while (pos >= 0) {
      if (Valid(s[pos])) {
        cnts[pos] = cnts[pos + 1] + (Valid({s, pos, 2}) ? cnts[pos + 2] : 0);
      } else {
        cnts[pos] = 0;
      }
      
      --pos;
    }
    
    return cnts[0];
  }
};
```

## 90. Subsets II

```cpp
class Solution {
public:
  using Subset = vector<int>;
  using Subsets = vector<Subset>;
  
  void FindAllSubsets(Subsets& found, Subset& current,
                     const vector<int>& nums, int pos) {
    found.emplace_back(current);
    
    // Continue find others without choosing the same element for more than
    // once.
    int p = pos;
    while (p < nums.size()) {
      if (p == pos || nums[p] != nums[p - 1]) {   // <--- DEDUP LOGIC HERE>
        current.emplace_back(nums[p]);
        FindAllSubsets(found, current, nums, p + 1);
        current.pop_back();
      }
      ++p;
    }
  }
  
  Subsets subsetsWithDup(Subset& nums) {
    std::sort(nums.begin(), nums.end());
    Subsets results;
    Subset current;
    FindAllSubsets(results, current, nums, 0);
    return results;
  }
};
```
