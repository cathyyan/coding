## 99. Recover Binary Search Tree  
## 98. Validate Binary Search Tree 
## 97. Interleaving String 
## 96. Unique Binary Search Trees  
## 95. Unique Binary Search Trees II 
## 94. Binary Tree Inorder Traversal 
## 93. Restore IP Addresses  
## 92. Reverse Linked List II  
## 91. Decode Ways 

Simple one dimentional DP.

```cpp
// 1-D DP.
class Solution {
public:
  bool Valid(char d) {
    return d >= '1' && d <= '9';
  }
  
  bool Valid(const string& s) {
    assert(s.length() == 2);
    int tmp = (s[0] - '0') * 10 + (s[1] - '0');
    return tmp >= 1 && tmp <= 26;
  }
  
  int numDecodings(string s) {
    if (s.empty()) return 0;
    
    std::vector<int> cnts(s.length() + 1, 0);
    int pos = s.length();
    cnts[pos--] = 1;
    cnts[pos] = Valid(s[pos]);
    pos--;
    while (pos >= 0) {
      if (Valid(s[pos])) {
        cnts[pos] = cnts[pos + 1] + (Valid({s, pos, 2}) ? cnts[pos + 2] : 0);
      } else {
        cnts[pos] = 0;
      }
      
      --pos;
    }
    
    return cnts[0];
  }
};
```

## 90. Subsets II

```cpp
class Solution {
public:
  using Subset = vector<int>;
  using Subsets = vector<Subset>;
  
  void FindAllSubsets(Subsets& found, Subset& current,
                     const vector<int>& nums, int pos) {
    found.emplace_back(current);
    
    // Continue find others without choosing the same element for more than
    // once.
    int p = pos;
    while (p < nums.size()) {
      if (p == pos || nums[p] != nums[p - 1]) {   // <--- DEDUP LOGIC HERE>
        current.emplace_back(nums[p]);
        FindAllSubsets(found, current, nums, p + 1);
        current.pop_back();
      }
      ++p;
    }
  }
  
  Subsets subsetsWithDup(Subset& nums) {
    std::sort(nums.begin(), nums.end());
    Subsets results;
    Subset current;
    FindAllSubsets(results, current, nums, 0);
    return results;
  }
};
```
