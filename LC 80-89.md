# LC 80-89

## 89. Gray Code 
## 88. Merge Sorted Array  
## 87. Scramble String 
## 86. Partition List  
## 85. Maximal Rectangle 
## 84. Largest Rectangle in Histogram  
## 83. Remove Duplicates from Sorted List  
## 82. Remove Duplicates from Sorted List II 
## 81. Search in Rotated Sorted Array II

## 80. Remove Duplicates from Sorted Array II

Solution 1: using two pointers to track the last and second last positions of `j`, i.e., `j1` and `j2`.

```cpp
// 20 ms
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if (nums.size() < 3) return nums.size();
        
        std::size_t i = 2;
        std::size_t j2 = 0, j1 = 1, j = 2;
        while (j < nums.size()) {
            if (nums[j] == nums[j1] && nums[j1] == nums[j2]) {
                j2 = j1;
                j1 = j;
                ++j;
            } else {
                j2 = j2 == i ? j : j2;
                j1 = j1 == i ? j : j1;
                std::swap(nums[i], nums[j]);
                j2 = j1;
                j1 = i;
                ++i;
                ++j;
            }
        }
        return i;
    }
};
```
A cleaner solution is based on the observation that, `i - 1` and `i - 2` always point to the last and second-last positions of `j`. :)

```cpp
// 16 ms
class Solution {
public:
    int removeDuplicates(std::vector<int>& nums) {
        if (nums.size() < 3) return nums.size();
        
        std::size_t i = 2, j = 2;
        while (j < nums.size()) {
            if (nums[j - 1] != nums[i - 2] || nums[j] != nums[i - 1]) {
                nums[i] = nums[j];
                ++i;
            }
            ++j;
        }
        return i;
    }
};
```
