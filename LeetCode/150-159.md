## 159. Longest Substring with At Most Two Distinct Characters 
## 158. Read N Characters Given Read4 II - Call multiple times 
## 157. Read N Characters Given Read4  
## 156. Binary Tree Upside Down  
## 155. Min Stack
## 154. Find Minimum in Rotated Sorted Array II
## 153. Find Minimum in Rotated Sorted Array 
## 152. Maximum Product Subarray 
## 151. Reverse Words in a String
## 150. Evaluate Reverse Polish Notation 

This stack approach worked super well: the code finished in 16ms.
```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> s;
        for (const auto& t : tokens) {
            if (isdigit(t.back())) {
                s.push(stoi(t));
                continue;
            }
            int n2 = s.top(); s.pop();
            int n1 = s.top(); s.pop();
            if (t == "+") {
                s.push(n1 + n2);
            } else if (t == "-") {
                s.push(n1 - n2);
            } else if (t == "*") {
                s.push(n1 * n2);
            } else if (t == "/") {
                s.push(n1 / n2);
            }
        }
        return s.top();
    }
};
```

But the linked-list based approach got TLE. Not sure why. Too many
string <-> integer conversions perhaps?

```cpp
class Solution {
public:
    int evalRPN(vector<string>& t) {
        list<string> tokens(t.begin(), t.end());
        auto it = tokens.begin();
        while (tokens.size() > 1) {
            if (IsOperator(*it)) {
                string res = Calculate(*std::prev(it, 2), *std::prev(it, 1), *it);
                it = tokens.erase(std::prev(it, 2), std::next(it));
                it = tokens.insert(it, res);
            cout << tokens.size() << endl;
            } else {
                ++it;
            }
        }
        return std::stoi(tokens.front());
    }
    
    bool IsOperator(const string& s) {
        return s == "+" || s == "-" || s == "*" || s == "/";
    }
    
    string Calculate(const string& op1, const string& op2, const string& op) {
        if (op == "+") {
            return std::to_string(std::stoi(op1) + std::stoi(op2));
        } else if (op == "-") {
            return std::to_string(std::stoi(op1) - std::stoi(op2));
        } else if (op == "*") {
            return std::to_string(std::stoi(op1) * std::stoi(op2));
        } else if (op == "/") {
            return std::to_string(std::stoi(op1) / std::stoi(op2));
        }
        return "";
    }
};
```
