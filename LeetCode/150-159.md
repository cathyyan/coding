## 159. Longest Substring with At Most Two Distinct Characters 
## 158. Read N Characters Given Read4 II - Call multiple times 
## 157. Read N Characters Given Read4  
## 156. Binary Tree Upside Down  
## 155. Min Stack
## 154. Find Minimum in Rotated Sorted Array II
## 153. Find Minimum in Rotated Sorted Array 
## 152. Maximum Product Subarray 
## 151. Reverse Words in a String

In-place reversal.

```cpp
// Reverse Words in a String
// E.g., "This is ABC" -> "ABC is This"
class Solution {
public:
  void reverseWords(string &s) {
    int good_until = 0;
    int cur_word_start = -1;
    int cur = 0;
    bool is_first_word = true;
    while (cur < s.length()) {
      if (s[cur] != ' ') {
        if (cur == 0 || s[cur - 1] == ' ') {  // starting a word
          cur_word_start = cur;
        }
        if (cur + 1 == s.length() || s[cur + 1] == ' ')  {  // ending a word
          if (!is_first_word) s[good_until++] = ' ';
          reverse(s, cur_word_start, cur, good_until);
          good_until += cur - cur_word_start + 1;
          is_first_word = false;
        }
      }
      ++cur;
    }
    s.resize(good_until);
    std::reverse(s.begin(), s.end());
  }
  
private:
  // Reverse a portion of string and save the results to the
  // specified location.
  void reverse(string& s, int start, int end, int to) {
    while (start <= end && to < start) {
      s[to++] = s[end--];
    }
    while (start <= end) {
      std::swap(s[start++], s[end--]);
    }
  }
};
```

## 150. Evaluate Reverse Polish Notation 

This stack approach worked super well: the code finished in 16ms.
```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> s;
        for (const auto& t : tokens) {
            if (isdigit(t.back())) {
                s.push(stoi(t));
                continue;
            }
            int n2 = s.top(); s.pop();
            int n1 = s.top(); s.pop();
            if (t == "+") {
                s.push(n1 + n2);
            } else if (t == "-") {
                s.push(n1 - n2);
            } else if (t == "*") {
                s.push(n1 * n2);
            } else if (t == "/") {
                s.push(n1 / n2);
            }
        }
        return s.top();
    }
};
```

But the linked-list based approach got TLE. Not sure why. Too many
string <-> integer conversions perhaps?

```cpp
class Solution {
public:
    int evalRPN(vector<string>& t) {
        list<string> tokens(t.begin(), t.end());
        auto it = tokens.begin();
        while (tokens.size() > 1) {
            if (IsOperator(*it)) {
                string res = Calculate(*std::prev(it, 2), *std::prev(it, 1), *it);
                it = tokens.erase(std::prev(it, 2), std::next(it));
                it = tokens.insert(it, res);
            cout << tokens.size() << endl;
            } else {
                ++it;
            }
        }
        return std::stoi(tokens.front());
    }
    
    bool IsOperator(const string& s) {
        return s == "+" || s == "-" || s == "*" || s == "/";
    }
    
    string Calculate(const string& op1, const string& op2, const string& op) {
        if (op == "+") {
            return std::to_string(std::stoi(op1) + std::stoi(op2));
        } else if (op == "-") {
            return std::to_string(std::stoi(op1) - std::stoi(op2));
        } else if (op == "*") {
            return std::to_string(std::stoi(op1) * std::stoi(op2));
        } else if (op == "/") {
            return std::to_string(std::stoi(op1) / std::stoi(op2));
        }
        return "";
    }
};
```
