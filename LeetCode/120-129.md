
## 129. Sum Root to Leaf Numbers 
## 128. Longest Consecutive Sequence 
## 127. Word Ladder
## 126. Word Ladder II 
## 125. Valid Palindrome 
## 124. Binary Tree Maximum Path Sum 
## 123. Best Time to Buy and Sell Stock III

DP:
```
m(s, t, d): the maximum profit at the end of day #d with #s stocks
            at hand and #t transactions done.
            
Initially,
m(s, 0, d) = 0, for all s and d;
m(s, t, 0) = 0, for all s and t;
m(1, 1, 0) = m(1, 3, 0) = -p_0;

Then:
m(0, t, d) = max( <t is positive even> ? m(1, t - 1, d - 1) + p_i : 0,
                  m(0, t, i - 1 );
m(1, t, d) = max( m(1, t, d - 1),
                  <t is positive odd> ? m(0, t - 1, d - 1) - p_i : 0);
                  
answer: max(m(0, 2, last_day), m(0, 4, last_day)).
```

```cpp
class Solution {
public:
    int maxProfit(const vector<int>& prices) {
        if (prices.empty()) return 0;
        
        // m(stocks, transactions, day)
        vector<vector<vector<int>>> m(
            2, vector<vector<int>>(5, vector<int>(prices.size(), 0)));
        m[1][1][0] = m[1][3][0] = -prices[0];
        
        for (int t = 1; t < 5; ++t) {
            for (std::size_t i = 1; i < prices.size(); ++i) {
                m[0][t][i] = std::max(
                    t > 0 && t % 2 == 0 ? m[1][t - 1][i - 1] + prices[i] : 0,
                    m[0][t][i - 1]);
                m[1][t][i] = std::max(
                    m[1][t][i - 1],
                    t > 0 && t % 2 == 1 ? m[0][t - 1][i - 1] - prices[i] : 0);
            }
        }
        
        return std::max(m[0][2][prices.size() - 1], m[0][4][prices.size() - 1]);
    }
};
```

## 122. Best Time to Buy and Sell Stock II 

Algorithm:
```
m(i, j): the maximum profit at the end of day #j with i stocks in hand.

Start:
m(0, 0) = 0;
m(1, 0) = -p_0;

Then:
m(0, i) = max(m(0, i - 1), m(1, i - 1) + p_i);
m(1, i) = max(m(0, i - 1) - p_i, m(1, i - 1));
```

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.empty()) return 0;
        
        vector<vector<int>> m(2, vector<int>(prices.size()));
        // i = 0
        m[0][0] = 0;
        m[1][0] = -prices[0];
        // otherwise
        for (std::size_t i = 1; i < prices.size(); ++i) {
            m[0][i] = std::max(m[1][i - 1] + prices[i], m[0][i - 1]);
            m[1][i] = std::max(m[1][i - 1],  m[0][i - 1] - prices[i]);
        }
        return m[0][prices.size() - 1];
    }
};
```

## 121. Best Time to Buy and Sell Stock

```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int max_profit = 0;
        int min_so_far = numeric_limits<int>::max();
        for (auto p : prices) {
            int tmp = p - min_so_far;
            if (tmp > max_profit) max_profit = tmp;
            if (p < min_so_far) min_so_far = p;
        }
        return max_profit;
    }
};
```

## 120. Triangle 

DP.

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        for (int i = static_cast<int>(triangle.size()) - 2; i >= 0; --i) {
            for (std::size_t j = 0; j < triangle[i].size(); ++j) {
                triangle[i][j] += std::min(triangle[i + 1][j], triangle[i + 1][j + 1]);
            }
        }
        return triangle[0][0];
    }
};
```
