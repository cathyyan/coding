## 119. Pascal's Triangle II  
## 118. Pascal's Triangle 
## 117. Populating Next Right Pointers in Each Node II  
## 116. Populating Next Right Pointers in Each Node 
## 115. Distinct Subsequences 

Simple DP.

```
m[i][j]: #of unique subsequences of s[i ...] that equal to t[j...].

m[k][t.length()] = 1 for all k in [0, s.length()].
m[s.length()][k] = 0 for all k in [0, t.length() - 1].
otherwise, m[i][j] = s[i] == t[j] ? (m[i + 1][j] + m[i + 1][j + 1]) : m[i + 1][j].
```

```cpp
// Count the unique subsequences of 's' that equal to 't'.
class Solution {
public:
    int numDistinct(string s, string t) {
        int R = s.size(), C = t.size();
        vector<vector<int>> m(R + 1, vector<int>(C + 1));
        for (int i = 0; i < R + 1; ++i) m[i][C] = 1;
        for (int i = 0; i < C; ++i) m[R][i] = 0;
        for (int i = R - 1; i >= 0; --i) {
            for (int j = 0; j < C; ++j) {
                m[i][j] = s[i] == t[j] ? m[i + 1][j] + m[i + 1][j + 1] : m[i + 1][j];
            }
        }
        return m[0][0];
    }
};
```

## 114. Flatten Binary Tree to Linked List  
Given a binary tree, flatten it to a linked list in-place.

```cpp
class Solution {
public:
    // Flatten the given tree and return the head and tail of
    // the resultant list.
    pair<TreeNode*, TreeNode*> Flatten(TreeNode* root) {
        if (!root) {
            return {nullptr, nullptr};
        }
        
        auto left_head_tail = Flatten(root->left);
        auto right_head_tail = Flatten(root->right);
        
        // Merge three parts:
        // - root
        // - flatten left tree
        // - flatten right tree
        TreeNode* head = root;
        TreeNode* tail = root;
        tail->left = nullptr;  // This has to be cleared to make OJ happy.
        if (left_head_tail.first) {
            tail->right = left_head_tail.first;
            tail = left_head_tail.second;
        }
        if (right_head_tail.first) {
            tail->right = right_head_tail.first;
            tail = right_head_tail.second;
        }
        tail->right = nullptr;
        
        return {head, tail};
    }
    
    void flatten(TreeNode* root) {
        Flatten(root);
    }
};
```

## 113. Path Sum II 

Still, remember __NOT__ to recurse to the `nullptr` level.
```cpp
class Solution {
public:
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        if (!root) return {};
        
        if (!root->left && !root->right) {
            if (sum == root->val) return { {root->val} };
            return {};
        }
        
        vector<vector<int>> sub_paths;
        if (root->left) {
            auto paths = pathSum(root->left, sum - root->val);
            sub_paths.insert(sub_paths.end(), paths.begin(), paths.end());
        }
        if (root->right) {
            auto paths = pathSum(root->right, sum - root->val);
            sub_paths.insert(sub_paths.end(), paths.begin(), paths.end());
        }
        if (!sub_paths.empty()) {
            for (auto& v : sub_paths) {
                v.insert(v.begin(), root->val);
            }
        }
        return sub_paths;
    }
};
```

## 112. Path Sum  

Given a binary tree and a sum, determine if the tree has a
root-to-leaf path such that adding up all the values along 
the path equals the given sum.

We cannot recurse to `root == nullptr` case and return
`sum == 0`, which would result in `true` while `false`
is expected in the case below.

```
sum = 3

tree:
  3
   \
    5
```

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (!root) return false;
        if (!root->left && !root->right) return root->val == sum;
        if (!root->left) return hasPathSum(root->right, sum - root->val);
        if (!root->right) return hasPathSum(root->left, sum - root->val);
        return hasPathSum(root->right, sum - root->val) || hasPathSum(root->left, sum - root->val);
    }
};
```

## 111. Minimum Depth of Binary Tree  

Given a binary tree, find its minimum depth. The minimum depth is
the number of nodes along the shortest path from the root node down
to the nearest leaf node.

Note the definition of the minimum depth.

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (!root) return 0;
        if (!root->left && !root->right) return 1;
        if (!root->left) return 1 + minDepth(root->right);
        if (!root->right) return 1 + minDepth(root->left);
        return 1 + std::min(minDepth(root->left), minDepth(root->right));
    }
};
```

## 110. Balanced Binary Tree

```cpp
class Solution {
public:
    bool isBalanced(TreeNode* root, int* height = nullptr) {
        if (!root) {
            if (height) *height = 0;
            return true;
        }
        int lh = 0, rh = 0;
        bool ret = isBalanced(root->left, &lh) &&
                   isBalanced(root->right, &rh) &&
                   std::abs(lh - rh) <= 1;
        if (height) *height = std::max(lh, rh) + 1;
        return ret;
    }
};
```
