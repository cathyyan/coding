## 119. Pascal's Triangle II  
## 118. Pascal's Triangle 
## 117. Populating Next Right Pointers in Each Node II  
## 116. Populating Next Right Pointers in Each Node 
## 115. Distinct Subsequences 
## 114. Flatten Binary Tree to Linked List  
## 113. Path Sum II 
## 112. Path Sum  

Given a binary tree and a sum, determine if the tree has a
root-to-leaf path such that adding up all the values along 
the path equals the given sum.

We cannot recurse to `root == nullptr` case and return
`sum == 0`, which would result in `true` while `false`
is expected in the case below.

```
sum = 3

tree:
  3
   \
    5
```

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (!root) return false;
        if (!root->left && !root->right) return root->val == sum;
        if (!root->left) return hasPathSum(root->right, sum - root->val);
        if (!root->right) return hasPathSum(root->left, sum - root->val);
        return hasPathSum(root->right, sum - root->val) || hasPathSum(root->left, sum - root->val);
    }
};
```

## 111. Minimum Depth of Binary Tree  

Given a binary tree, find its minimum depth. The minimum depth is
the number of nodes along the shortest path from the root node down
to the nearest leaf node.

Note the definition of the minimum depth.

```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (!root) return 0;
        if (!root->left && !root->right) return 1;
        if (!root->left) return 1 + minDepth(root->right);
        if (!root->right) return 1 + minDepth(root->left);
        return 1 + std::min(minDepth(root->left), minDepth(root->right));
    }
};
```

## 110. Balanced Binary Tree

```cpp
class Solution {
public:
    bool isBalanced(TreeNode* root, int* height = nullptr) {
        if (!root) {
            if (height) *height = 0;
            return true;
        }
        int lh = 0, rh = 0;
        bool ret = isBalanced(root->left, &lh) &&
                   isBalanced(root->right, &rh) &&
                   std::abs(lh - rh) <= 1;
        if (height) *height = std::max(lh, rh) + 1;
        return ret;
    }
};
```
