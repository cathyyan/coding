## 139. Word Break 
## 138. Copy List with Random Pointer
## 137. Single Number II 
## 136. Single Number
## 135. Candy
## 134. Gas Station
## 133. Clone Graph
## 132. Palindrome Partitioning II 
## 131. Palindrome Partitioning
## 130. Surrounded Regions 

For each 'O' grid on the edge, run BFS with it as origin and label all reachable
ones with 'Y'. Then check each grid and change 'O' to 'X' and 'Y' to 'O'.

```cpp
class Solution {
public:
    using Board = vector<vector<char>>;
    using Position = pair<int, int>;
    
    // BFS starting from the given position.
    void BFS(Board& board, Position p) {
        const int directions[][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        queue<Position> q;
        board[p.first][p.second] = 'Y';
        q.push(p);
        while (!q.empty()) {
            Position f = q.front(); q.pop();
            for (int d = 0; d < 4; ++d) {
                Position next = {f.first + directions[d][0], f.second + directions[d][1]};
                if (next.first >= 0 && next.first < board.size() &&
                    next.second >= 0 && next.second < board.front().size() &&
                    board[next.first][next.second] == 'O') {
                    board[next.first][next.second] = 'Y';
                    q.push(next);
                }
            }
        }
    }
    
    void solve(Board& board) {
        for (size_t i = 0; i < board.size(); ++i) {
            for (size_t j = 0; j < board[i].size(); ++j) {
                if (board[i][j] == 'O' &&
                    (!i || i + 1 == board.size() || !j || j + 1 == board[i].size())) {
                    BFS(board, {i, j});
                }
            }
        }
        for (size_t i = 0; i < board.size(); ++i) {
            for (size_t j = 0; j < board[i].size(); ++j) {
                if (board[i][j] == 'Y') {
                    board[i][j] = 'O';
                } else if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
            }
        }
        
    }
};
```
