## 139. Word Break 
## 138. Copy List with Random Pointer
## 137. Single Number II 
## 136. Single Number
## 135. Candy
## 134. Gas Station
## 133. Clone Graph
## 132. Palindrome Partitioning II 

tried the same backtrace approach but got TLE -:(

```cpp
class LastSolution {
public:
    bool IsPalindrome(const string& s, int start, int end) {
        while (start < end) {
            if (s[start++] != s[end--]) return false;
        }
        return true;
    }

    void FindAll(int& rs, int current, const string& s, int pos) {
        if (pos == s.length()) {
            if (current < rs) rs = current;
            return;
        }
        
        if (current + 1 >= rs) return;
        
        // for (int p = pos; p < s.length(); ++p) {
        for (int p = static_cast<int>(s.length()) - 1; p >= pos; --p) {
            if (IsPalindrome(s, pos, p)) {
                FindAll(rs, current + 1, s, p + 1);
            }
        }
    }

    int partition(string s) {
        int rs = numeric_limits<int>::max();
        FindAll(rs, 0, s, 0);
        return rs;
    }
};

class Solution {
public:
    int minCut(string s) {
        return LastSolution().partition(s);
    }
};
```

Still unsure why my DP solution below got TLE.

```
class Solution {
public:
    vector<vector<bool>> PreCompute(const string& s) {
        int len = s.length();
        vector<vector<bool>> b(len, vector<bool>(len, false));
        for (int k = 0; k < len; ++k) {
            for (int x = 0, y = k; y < len; ++x, ++y) {
                b[x][y] = 
                    (k == 0) ||
                    (k == 1 && s[x] == s[y]) ||
                    (k > 1 && s[x] == s[y] && b[x + 1][y - 1]);
            }
        }
        return b;
    }
    
    bool IsPalindrome(const string& s, int start, int end) {
        while (start < end) {
            if (s[start++] != s[end--]) return false;
        }
        return true;
    }

    int MinCut(const string& s, int start, int end) {
        // if (is_palindrome_[start][end]) return 0;
        if (IsPalindrome(s, start, end)) return 0;
        
        int min_cuts = numeric_limits<int>::max();
        for (int k = start; k < end; ++k) {
            int tmp = MinCutWithDict(s, k + 1, end);
            if (tmp >= min_cuts) continue;
            tmp += MinCutWithDict(s, start, k) + 1;
            if (tmp < min_cuts) min_cuts = tmp;
        }
        return min_cuts;
    }
    
    int MinCutWithDict(const string& s, int start, int end) {
        int key = start * 1000 + end;
        if (dict_.find(key) == dict_.end()) {
            dict_[key] = MinCut(s, start, end);
        }
        return dict_[key];
    }

    int minCut(const string& s) {
        if (s.empty()) return 0;
        cout << s.length();
        // is_palindrome_ = PreCompute(s);
        return MinCutWithDict(s, 0, s.length() - 1);
    }
    
private:
    vector<vector<bool>> is_palindrome_;
    unordered_map<int, int> dict_;
};
```

DP Solution passed. Note the bottom-up order for the upper-right half.

```cpp
class Solution {
public:
    int minCut(const string& s) {
        int len = s.length();
        vector<int> min_cuts(len + 1);
        for (int i = 0; i < len + 1; ++i) {
            min_cuts[i] = len - i;
        }
        vector<vector<bool>> b(len, vector<bool>(len, false));
        for (int x = len - 1; x >= 0; x--) {  
            for (int y = x; y < len; y++) {  
                int k = y - x;
                b[x][y] = 
                    (k == 0) ||
                    (k == 1 && s[x] == s[y]) ||
                    (k > 1 && s[x] == s[y] && b[x + 1][y - 1]);
                if (b[x][y]) {
                    min_cuts[x] = min(min_cuts[x], min_cuts[y + 1] + 1);
                }
            }
        }
        return min_cuts[0] - 1;
    }
};
```

## 131. Palindrome Partitioning

Backtrace.

```cpp
class Solution {
public:
    using Result = vector<string>;
    using Results = vector<vector<string>>;
    
    bool IsPalindrome(const string& s, int start, int end) {
        while (start < end) {
            if (s[start++] != s[end--]) return false;
        }
        return true;
    }
    
    void FindAll(Results& rs, Result& current, const string& s, int pos) {
        if (pos == s.length()) {
            rs.emplace_back(current);
            return;
        }
        for (int p = pos; p < s.length(); ++p) {
            if (IsPalindrome(s, pos, p)) {
                current.emplace_back(s.substr(pos, p - pos + 1));
                FindAll(rs, current, s, p + 1);
                current.pop_back();
            }
        }
    }
    
    Results partition(string s) {
        Results rs;
        Result r;
        FindAll(rs, r, s, 0);
        return rs;
    }
};
```

## 130. Surrounded Regions 

For each 'O' grid on the edge, run BFS with it as origin and label all reachable
ones with 'Y'. Then check each grid and change 'O' to 'X' and 'Y' to 'O'.

```cpp
class Solution {
public:
    using Board = vector<vector<char>>;
    using Position = pair<int, int>;
    
    // BFS starting from the given position.
    void BFS(Board& board, Position p) {
        const int directions[][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        queue<Position> q;
        board[p.first][p.second] = 'Y';
        q.push(p);
        while (!q.empty()) {
            Position f = q.front(); q.pop();
            for (int d = 0; d < 4; ++d) {
                Position next = {f.first + directions[d][0], f.second + directions[d][1]};
                if (next.first >= 0 && next.first < board.size() &&
                    next.second >= 0 && next.second < board.front().size() &&
                    board[next.first][next.second] == 'O') {
                    board[next.first][next.second] = 'Y';
                    q.push(next);
                }
            }
        }
    }
    
    void solve(Board& board) {
        for (size_t i = 0; i < board.size(); ++i) {
            for (size_t j = 0; j < board[i].size(); ++j) {
                if (board[i][j] == 'O' &&
                    (!i || i + 1 == board.size() || !j || j + 1 == board[i].size())) {
                    BFS(board, {i, j});
                }
            }
        }
        for (size_t i = 0; i < board.size(); ++i) {
            for (size_t j = 0; j < board[i].size(); ++j) {
                if (board[i][j] == 'Y') {
                    board[i][j] = 'O';
                } else if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
            }
        }
        
    }
};
```
