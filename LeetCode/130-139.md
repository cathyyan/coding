## 139. Word Break 
## 138. Copy List with Random Pointer
## 137. Single Number II 
## 136. Single Number
## 135. Candy

In the first iteration from left to right, if the one has higher rating
than its left, its candies should be one more than its left buddy's
candies.

In the second iterator from right to left, if the one has higher rating
than its right but doesn't have more candies, give it more then.

```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> candies(ratings.size(), 1);
        for (size_t i = 1; i < candies.size(); ++i) {
            if (ratings[i] > ratings[i - 1]) {
                candies[i] = candies[i - 1] + 1;
            }
        }
        for (int i = static_cast<int>(candies.size()) - 2; i >= 0; --i) {
            if (ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {
                candies[i] = candies[i + 1] + 1;
            }
        }
        
        int sum = 0;
        for (auto k : candies) sum += k;
        return sum;
    }
};
```

## 134. Gas Station

Observation #1:
```
If #i is the solution, then #i is able to reach any other station.
```

Observation #2:
```
If #i is the only solution, then no other #j can reach #i.
```
```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int sum = 0;
        
        // Where we start.
        int from = 0;
        // If we had reached #station, how much remaining gas we would have.
        int remaining = 0;
        int station = 0;
        while (station < gas.size()) {
            if (remaining < 0) {
                // Unable to reach station from station #from.
                remaining = 0;
                from = station;
            }
            int c = gas[station] - cost[station];
            remaining += c;
            sum += c;
            ++station;
        }
        return sum < 0 ? -1 : from;
    }
};
```
## 133. Clone Graph

```cpp
class Solution {
public:
    // BFS a graph and call the given callback on each visited
    // graph node.
    void BFS(UndirectedGraphNode* node,
             std::function<void(UndirectedGraphNode*)> cb) {
        if (!node) return;
        
        std::queue<UndirectedGraphNode*> q;
        std::unordered_set<UndirectedGraphNode*> visited;
        q.push(node);
        visited.insert(node);
        while(!q.empty()) {
            UndirectedGraphNode* front = q.front();
            q.pop();
            cb(front);
            for (UndirectedGraphNode* neighbor : front->neighbors) {
                if (visited.find(neighbor) == visited.end()) {
                    visited.insert(neighbor);
                    q.push(neighbor);
                }
            }
        }
    }

    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
        UndirectedGraphNode* new_node = nullptr;
        std::unordered_map<UndirectedGraphNode*, UndirectedGraphNode*> mapping;
        BFS(node, [&](UndirectedGraphNode* old_node) {
            UndirectedGraphNode* new_node_copy = nullptr;
            if (mapping.find(old_node) == mapping.end()) {
                new_node_copy = new UndirectedGraphNode(old_node->label);
                mapping[old_node] = new_node_copy;
            } else {
                new_node_copy = mapping[old_node];
            }
            for (UndirectedGraphNode* nb : old_node->neighbors) {
                UndirectedGraphNode* nn = nullptr;
                if (mapping.find(nb) == mapping.end()) {
                    nn = new UndirectedGraphNode(nb->label);
                    mapping[nb] = nn;
                } else {
                    nn = mapping[nb];
                }
                new_node_copy->neighbors.emplace_back(nn);
            }
            if (!new_node) new_node = new_node_copy;
        });
        return new_node;
    }
};
```

## 132. Palindrome Partitioning II 

tried the same backtrace approach but got TLE -:(

```cpp
class LastSolution {
public:
    bool IsPalindrome(const string& s, int start, int end) {
        while (start < end) {
            if (s[start++] != s[end--]) return false;
        }
        return true;
    }

    void FindAll(int& rs, int current, const string& s, int pos) {
        if (pos == s.length()) {
            if (current < rs) rs = current;
            return;
        }
        
        if (current + 1 >= rs) return;
        
        // for (int p = pos; p < s.length(); ++p) {
        for (int p = static_cast<int>(s.length()) - 1; p >= pos; --p) {
            if (IsPalindrome(s, pos, p)) {
                FindAll(rs, current + 1, s, p + 1);
            }
        }
    }

    int partition(string s) {
        int rs = numeric_limits<int>::max();
        FindAll(rs, 0, s, 0);
        return rs;
    }
};

class Solution {
public:
    int minCut(string s) {
        return LastSolution().partition(s);
    }
};
```

Still unsure why my DP solution below got TLE.

```
class Solution {
public:
    vector<vector<bool>> PreCompute(const string& s) {
        int len = s.length();
        vector<vector<bool>> b(len, vector<bool>(len, false));
        for (int k = 0; k < len; ++k) {
            for (int x = 0, y = k; y < len; ++x, ++y) {
                b[x][y] = 
                    (k == 0) ||
                    (k == 1 && s[x] == s[y]) ||
                    (k > 1 && s[x] == s[y] && b[x + 1][y - 1]);
            }
        }
        return b;
    }
    
    bool IsPalindrome(const string& s, int start, int end) {
        while (start < end) {
            if (s[start++] != s[end--]) return false;
        }
        return true;
    }

    int MinCut(const string& s, int start, int end) {
        // if (is_palindrome_[start][end]) return 0;
        if (IsPalindrome(s, start, end)) return 0;
        
        int min_cuts = numeric_limits<int>::max();
        for (int k = start; k < end; ++k) {
            int tmp = MinCutWithDict(s, k + 1, end);
            if (tmp >= min_cuts) continue;
            tmp += MinCutWithDict(s, start, k) + 1;
            if (tmp < min_cuts) min_cuts = tmp;
        }
        return min_cuts;
    }
    
    int MinCutWithDict(const string& s, int start, int end) {
        int key = start * 1000 + end;
        if (dict_.find(key) == dict_.end()) {
            dict_[key] = MinCut(s, start, end);
        }
        return dict_[key];
    }

    int minCut(const string& s) {
        if (s.empty()) return 0;
        cout << s.length();
        // is_palindrome_ = PreCompute(s);
        return MinCutWithDict(s, 0, s.length() - 1);
    }
    
private:
    vector<vector<bool>> is_palindrome_;
    unordered_map<int, int> dict_;
};
```

DP Solution passed. Note the bottom-up order for the upper-right half.

```cpp
class Solution {
public:
    int minCut(const string& s) {
        int len = s.length();
        vector<int> min_cuts(len + 1);
        for (int i = 0; i < len + 1; ++i) {
            min_cuts[i] = len - i;
        }
        vector<vector<bool>> b(len, vector<bool>(len, false));
        for (int x = len - 1; x >= 0; x--) {  
            for (int y = x; y < len; y++) {  
                int k = y - x;
                b[x][y] = 
                    (k == 0) ||
                    (k == 1 && s[x] == s[y]) ||
                    (k > 1 && s[x] == s[y] && b[x + 1][y - 1]);
                if (b[x][y]) {
                    min_cuts[x] = min(min_cuts[x], min_cuts[y + 1] + 1);
                }
            }
        }
        return min_cuts[0] - 1;
    }
};
```

## 131. Palindrome Partitioning

Backtrace.

```cpp
class Solution {
public:
    using Result = vector<string>;
    using Results = vector<vector<string>>;
    
    bool IsPalindrome(const string& s, int start, int end) {
        while (start < end) {
            if (s[start++] != s[end--]) return false;
        }
        return true;
    }
    
    void FindAll(Results& rs, Result& current, const string& s, int pos) {
        if (pos == s.length()) {
            rs.emplace_back(current);
            return;
        }
        for (int p = pos; p < s.length(); ++p) {
            if (IsPalindrome(s, pos, p)) {
                current.emplace_back(s.substr(pos, p - pos + 1));
                FindAll(rs, current, s, p + 1);
                current.pop_back();
            }
        }
    }
    
    Results partition(string s) {
        Results rs;
        Result r;
        FindAll(rs, r, s, 0);
        return rs;
    }
};
```

## 130. Surrounded Regions 

For each 'O' grid on the edge, run BFS with it as origin and label all reachable
ones with 'Y'. Then check each grid and change 'O' to 'X' and 'Y' to 'O'.

```cpp
class Solution {
public:
    using Board = vector<vector<char>>;
    using Position = pair<int, int>;
    
    // BFS starting from the given position.
    void BFS(Board& board, Position p) {
        const int directions[][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        queue<Position> q;
        board[p.first][p.second] = 'Y';
        q.push(p);
        while (!q.empty()) {
            Position f = q.front(); q.pop();
            for (int d = 0; d < 4; ++d) {
                Position next = {f.first + directions[d][0], f.second + directions[d][1]};
                if (next.first >= 0 && next.first < board.size() &&
                    next.second >= 0 && next.second < board.front().size() &&
                    board[next.first][next.second] == 'O') {
                    board[next.first][next.second] = 'Y';
                    q.push(next);
                }
            }
        }
    }
    
    void solve(Board& board) {
        for (size_t i = 0; i < board.size(); ++i) {
            for (size_t j = 0; j < board[i].size(); ++j) {
                if (board[i][j] == 'O' &&
                    (!i || i + 1 == board.size() || !j || j + 1 == board[i].size())) {
                    BFS(board, {i, j});
                }
            }
        }
        for (size_t i = 0; i < board.size(); ++i) {
            for (size_t j = 0; j < board[i].size(); ++j) {
                if (board[i][j] == 'Y') {
                    board[i][j] = 'O';
                } else if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
            }
        }
        
    }
};
```
