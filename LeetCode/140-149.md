## 149. Max Points on a Line 
## 148. Sort List
## 147. Insertion Sort List
## 146. LRU Cache
## 145. Binary Tree Postorder Traversal
## 144. Binary Tree Preorder Traversal 
## 143. Reorder List 
## 142. Linked List Cycle II 
## 141. Linked List Cycle
## 140. Word Break II

Find if a solution exists.

```cpp
class CheckSolution {
public:
    bool wordBreak(string s, unordered_set<string>& wordDict) {
        if (s.empty()) return true;
        
        vector<bool> b(s.length(), false);
        b.back() = wordDict.find(string(1, s.back())) != wordDict.end();
        for (int i = static_cast<int>(s.length()) - 1; i >= 0; --i) {
            if (wordDict.count(s.substr(i))) {
                b[i] = true;
                continue;
            }
            for (int k = i + 1; k < s.length(); ++k) {
                if (b[k] && wordDict.count(s.substr(i, k - i))) {
                    b[i] = true;
                    break;
                }
            }
        }
        return b[0];
    }
};

class Solution {
public:
    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {
        if (!CheckSolution().wordBreak(s, wordDict)) return {};
        
        if (s.empty()) return {};

        vector<vector<string>> b(s.length());
        if (wordDict.count(string(1, s.back()))) {
            b.back().emplace_back(1, s.back());
        }
        for (int i = static_cast<int>(s.length()) - 2; i >= 0; --i) {
            if (wordDict.count(s.substr(i))) {
                b[i].emplace_back(s.substr(i));
            }
            for (int k = i + 1; k < s.length(); ++k) {
                if (!b[k].empty() && wordDict.count(s.substr(i, k - i))) {
                    for (const auto& seg : b[k]) {
                        b[i].emplace_back(s.substr(i, k - i) + " " + seg);
                    }
                }
            }
        }
        return b.front();
    }
};
```
