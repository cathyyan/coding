## 149. Max Points on a Line 
## 148. Sort List
## 147. Insertion Sort List
## 146. LRU Cache
## 145. Binary Tree Postorder Traversal
## 144. Binary Tree Preorder Traversal 

Iterative traversal using a stack. This approach taks O(n) space. Is there
a O(1) space one?

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        if (!root) return {};
        
        vector<int> results;
        stack<TreeNode*> s;
        s.push(root);
        while (!s.empty()) {
            TreeNode* tmp = s.top();
            s.pop();
            results.emplace_back(tmp->val);
            if (tmp->right) { s.push(tmp->right); }
            if (tmp->left) { s.push(tmp->left); }
        }
        return results;
    }
};
```

## 143. Reorder List 

Recursive (`O(n^2)`), but TLE.

```cpp
class Solution {
public:
    void reorderList(ListNode* head) {
        if (!head) return;
        
        ListNode* tail_prev = nullptr;
        ListNode* tail = head;
        while (tail->next) {
            tail_prev = tail;
            tail = tail->next;
        }
        if (tail == head) return;
        tail_prev->next = nullptr;
        reorderList(head->next);
        tail->next = head->next;
        head->next = tail;
    }
};
```

AC'ed one (with `O(n)`):
```cpp
class Solution {
public:
    ListNode* Reverse(ListNode* head) {
        ListNode* reversed_head = nullptr;
        while (head) {
            ListNode* tmp = head->next;
            head->next = reversed_head;
            reversed_head = head;
            head = tmp;
        }
        return reversed_head;
    }
    
    void reorderList(ListNode* head) {
        ListNode* upto = head;
        ListNode* mid = head;
        ListNode* mid_prev = nullptr;
        while (upto) {
            upto = upto->next;
            if (upto) upto = upto->next;
            mid_prev = mid;
            mid = mid->next;
        }
        if (!mid) return;
        mid_prev->next = nullptr;
        
        // Reverse the second half pointed to by 'mid'.
        mid = Reverse(mid);
        
        ListNode* prev = head;
        ListNode* to_insert = mid;
        while (prev && to_insert) {
            ListNode* tmp_prev = prev->next;
            ListNode* tmp_to_insert = to_insert->next;
            
            if (prev->next) {
                to_insert->next = prev->next;
            }
            prev->next = to_insert;
            
            prev = tmp_prev;
            to_insert = tmp_to_insert;
        }
    }
};
```

## 142. Linked List Cycle II 

When there exists a cycle, let's say `fast` and `slow` meet
at node `K`. When they meet, they have moved `X + nL + K` and
`X + kL + K` steps, respectively. We also have

```
X + nL + K = 2 * (X + kL + K)
(n - 2k)L = X + K
```
which suggests that another `K` steps will get us onto the
merge point.

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        // Part I: Check whether we have any cycle.
        ListNode* slow = head;
        ListNode* fast = head;
        while (slow != nullptr && fast != nullptr) {
            slow = slow->next;
            fast = fast->next;
            if (fast != nullptr) fast = fast->next;
            if (slow == fast) { break; }
        }
        if (!slow || !fast) return nullptr;
        
        // Part II: Find the merge point.
        slow = head;
        while (slow != fast) {
            slow = slow->next;
            fast = fast->next;
        }
        return slow;
    }
};
```

## 141. Linked List Cycle

Two pointers, one moving one step at a time while the other moving two at a time.
If they meet, this means there is a cycle; otherwise, no cycle.

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (!head) return false;
        
        ListNode* fast = head->next;
        ListNode* slow = head;
        while (fast && slow && fast != slow) {
            slow = slow->next;
            fast = fast->next;
            if (fast) fast = fast->next;
        }
        return fast && fast == slow;
    }
};
```

clearner way:

```cpp
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while (slow != nullptr && fast != nullptr) {
            slow = slow->next;
            fast = fast->next;
            if (fast != nullptr) fast = fast->next;
            if (slow == fast) { break; }
        }
        return slow && fast;
    }
};
```

## 140. Word Break II

Find if a solution exists. This approach took 8ms and was faster than >80%.

```cpp
class CheckSolution {
public:
    bool wordBreak(string s, unordered_set<string>& wordDict) {
        if (s.empty()) return true;
        
        vector<bool> b(s.length(), false);
        b.back() = wordDict.find(string(1, s.back())) != wordDict.end();
        for (int i = static_cast<int>(s.length()) - 1; i >= 0; --i) {
            if (wordDict.count(s.substr(i))) {
                b[i] = true;
                continue;
            }
            for (int k = i + 1; k < s.length(); ++k) {
                if (b[k] && wordDict.count(s.substr(i, k - i))) {
                    b[i] = true;
                    break;
                }
            }
        }
        return b[0];
    }
};

class Solution {
public:
    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {
        if (!CheckSolution().wordBreak(s, wordDict)) return {};
        
        if (s.empty()) return {};

        vector<vector<string>> b(s.length());
        if (wordDict.count(string(1, s.back()))) {
            b.back().emplace_back(1, s.back());
        }
        for (int i = static_cast<int>(s.length()) - 2; i >= 0; --i) {
            if (wordDict.count(s.substr(i))) {
                b[i].emplace_back(s.substr(i));
            }
            for (int k = i + 1; k < s.length(); ++k) {
                if (!b[k].empty() && wordDict.count(s.substr(i, k - i))) {
                    for (const auto& seg : b[k]) {
                        b[i].emplace_back(s.substr(i, k - i) + " " + seg);
                    }
                }
            }
        }
        return b.front();
    }
};
```
