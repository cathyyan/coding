
## Jump Game I

```cpp
class Solution {
public:
  bool canJump(const std::vector<int>& nums) {
    int jumps = 0;  // How many times we have jumped.
    int cur_reach = 0;  // Where the last jump ends.
    int next_max_reach = -1;  // Where the biggest next jump will be.
    
    int pos = 0;
    while (pos <= cur_reach && pos + 1 < nums.size()) {
      next_max_reach = std::max(next_max_reach, pos + nums[pos]);
      if (pos == cur_reach) {
        cur_reach = next_max_reach;
        ++jumps;
      }
      ++pos;
    }
    
    return pos <= cur_reach;   // <--- NOTE THIS RETURN CONDITION!!!
  }
};
```

## Maximum Subarray 

Standard 1-dimentional DP.

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        std::vector<int> max(nums.size());
        int result = std::numeric_limits<int>::min();
        for (std::size_t i = 0; i < nums.size(); ++i) {
            max[i] = std::max(nums[i], i ? nums[i] + max[i - 1] : std::numeric_limits<int>::min());
            result = std::max(max[i], result);
        }
        return result;
    }
};
```

## N-Queens II

Reuse N-Queens' solution here.

```cpp
class Solution {
public:
    int totalNQueens(int n) {
        return NQueensSolution().solveNQueens(n).size();
    }
};
```

## N-Queens

Should iterate row by row, instead of cell by cell.

```cpp
class Solution {
public:
  using Board = std::vector<std::string>;
  using Boards = std::vector<Board>;
  
  static constexpr char QUEEN = 'Q';
  static constexpr char EMPTY = '.';
  
  bool put(Board& b, int x, int y) {
    if (rows_.count(x) == 0 &&
        columns_.count(y) == 0 &&
        sums_.count(x + y) == 0 &&
        yx_diffs_.count(y - x) == 0) {
      rows_.insert(x);
      columns_.insert(y);
      sums_.insert(x + y);
      yx_diffs_.insert(y - x);
      b[x][y] = QUEEN;
      return true;
    }
    return false;
  }
  
  void remove(Board& b, int x, int y) {
    rows_.erase(x);
    columns_.erase(y);
    sums_.erase(x + y);
    yx_diffs_.erase(y - x);
    b[x][y] = EMPTY;
  }
  
  // Choose a value for row 'r'.
  void search(Boards& bs, Board& b, int queens_left, int r) {
    if (r >= static_cast<int>(b.size())) {
      if (queens_left == 0) {
        bs.emplace_back(b);
        // pr(b);
      }
      return;
    }    
    
    for (std::size_t c = 0; c < b.size(); ++c) {
      if (queens_left && put(b, r, c)) {
        search(bs, b, queens_left - 1, r + 1);
        remove(b, r, c);
      }
    }
  }
  
  Boards solveNQueens(int n) {
    Boards bs;
    Board b(n, std::string(n, EMPTY));
    search(bs, b, n, 0);
    return bs;
  }
  
 private:
  std::unordered_set<int> rows_;
  std::unordered_set<int> columns_;
  std::unordered_set<int> sums_;
  std::unordered_set<int> yx_diffs_;
};

```

## Pow(x, n) 

Easy, but pay attention to `n = -2147483648`, for which you cannot negative (since it may overflow `int` otherwise).

```cpp
class Solution {
 public:
  double myPow(double x, int n) {
    long long k = n;
    
    bool multiply = true;;
    if (k < 0) {
      multiply = false;
      k = -k;
    }
    
    double result = 1.0;
    while (k) {
      if (k % 2) {
        if (multiply)
          result *= x;
        else
          result /= x;
      }
      x *= x;
      k >>= 1;
    }
    return result;
  }
};
```
