# LC 60-69

## 69. Sqrt(x) 
## 68. Text Justification  
## 67. Add Binary  
## 66. Plus One  
## 65. Valid Number  
## 64. Minimum Path Sum  
## 63. Unique Paths II 
## 62. Unique Paths  

Use the following formula:
```
answer = C(n - 1 + m - 1, n - 1)
```

```cpp
class Solution {
public:
    int c(int n, int m) {
        if (m >= n || m == 0) return 1;
        if (m == 1) return n;
        return cc(n - 1, m - 1) + cc(n - 1, m);
    }
    
    std::unordered_map<int, int> dict;
    
    int cc(int n, int m) {
        int k = n * 100 + m;
        if (dict.count(k) > 0) {
            return dict[k];
        }
        int ans = c(n, m);
        dict[k] = ans;
        return ans;
    }
    
    int uniquePaths(int m, int n) {
        return cc(m - 1 + n - 1, m - 1);
    }
};
```

## 61. Rotate List 

Variant of kth-last node.

```cpp
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (head == nullptr) return nullptr; 
        
        // Go to the last tail node.
        ListNode* tail = head;
        int len = 1;
        while (tail->next) {
            tail = tail->next;
            ++len;
        }
        
        k = k % len;
        if (k == 0) return head;
        
        ListNode* first = head;
        for (int i = 0; i < k; ++i) first = first->next;
        
        ListNode* second = head;
        ListNode* prev = nullptr;
        while (first) {
            prev = second;
            second = second->next;
            first = first->next;
        }
        // 'second' now points to the new head.
        tail->next = head;
        prev->next = nullptr;
        return second;
    }
};
```

## 60. Permutation Sequence

```cpp
class Solution {
 public:
  int factorial(int n) {
    return !n ? 1 : n * factorial(n - 1);
  }
  
  std::string getPermutation(int n, int k) {
    k = k - 1;
    
    int fn = factorial(n);
    std::vector<int> left(n);
    std::iota(left.begin(), left.end(), 1);
    std::string result;
    while (!left.empty()) {
      fn /= left.size();
      int select = k / fn;
      result.append(1, '0' + left.at(select));
      left.erase(std::begin(left) + select);
      k %= fn;
    }
    return result;
  }
};
```
